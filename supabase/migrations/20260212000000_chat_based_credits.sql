-- =============================================================================
-- MIGRATION: Chat-Based Credits System
-- =============================================================================
-- Replaces the unused per-user billing system with per-chat credits.
-- Each chat gets 50 free credits on creation. 1 credit = 1 participant per round.
--
-- New tables:
--   chat_credits          — one row per chat, tracks credit balance
--   chat_credit_transactions — audit log of all credit changes
--   round_funding         — tracks which participants are funded per round
--
-- New functions:
--   fund_round_participants()    — deduct credits and record funded participants
--   fund_mid_round_join()        — fund a late joiner if credits available
--   can_round_start()            — check if enough credits for all participants
--   get_funded_participant_count() — count funded participants for a round
--   is_participant_funded()      — check if a specific participant is funded
--   add_chat_credits()           — add purchased credits (idempotent via Stripe ID)
--   check_credit_resume()        — resume a credit-paused round after purchase
--
-- Modified functions:
--   create_round_for_cycle()             — credit-gate round creation
--   check_auto_start_on_participant_join — fund mid-round joiners
--   check_early_advance_on_proposition   — use funded count for thresholds
--   check_early_advance_on_skip          — use funded count for thresholds
--   check_early_advance_on_rating        — use funded count for thresholds
--   check_early_advance_on_rating_skip   — use funded count for thresholds
--
-- Cleanup:
--   Drops old per-user billing trigger (trg_round_winner_track_usage)
-- =============================================================================


-- =============================================================================
-- STEP 1: New Tables
-- =============================================================================

-- Per-chat credit balance
CREATE TABLE public.chat_credits (
    id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    chat_id     BIGINT UNIQUE NOT NULL REFERENCES public.chats(id) ON DELETE CASCADE,
    credit_balance INTEGER NOT NULL DEFAULT 50 CHECK (credit_balance >= 0),
    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

ALTER TABLE public.chat_credits ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE public.chat_credits IS
'Per-chat credit balance. 1 credit = 1 participant per round. 50 free on creation.';


-- Audit log of credit changes
CREATE TABLE public.chat_credit_transactions (
    id              BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    chat_id         BIGINT NOT NULL REFERENCES public.chats(id) ON DELETE CASCADE,
    transaction_type TEXT NOT NULL CHECK (transaction_type IN (
        'initial', 'round_start', 'mid_round_join', 'purchase'
    )),
    amount          INTEGER NOT NULL,
    balance_after   INTEGER NOT NULL,
    round_id        BIGINT REFERENCES public.rounds(id) ON DELETE SET NULL,
    participant_count INTEGER,
    stripe_checkout_session_id TEXT,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Enforce idempotency for Stripe purchases
CREATE UNIQUE INDEX idx_chat_credit_txn_stripe_session
    ON public.chat_credit_transactions (stripe_checkout_session_id)
    WHERE stripe_checkout_session_id IS NOT NULL;

ALTER TABLE public.chat_credit_transactions ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE public.chat_credit_transactions IS
'Audit log for chat credit changes. Stripe purchases are idempotent via unique session ID.';


-- Per-round funding: which participants are funded (source of truth for thresholds)
CREATE TABLE public.round_funding (
    id             BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    round_id       BIGINT NOT NULL REFERENCES public.rounds(id) ON DELETE CASCADE,
    participant_id BIGINT NOT NULL REFERENCES public.participants(id) ON DELETE CASCADE,
    created_at     TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (round_id, participant_id)
);

ALTER TABLE public.round_funding ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE public.round_funding IS
'Tracks which participants are funded for each round. Only funded participants count toward thresholds.';


-- =============================================================================
-- STEP 2: Realtime Publication
-- =============================================================================

ALTER PUBLICATION supabase_realtime ADD TABLE public.chat_credits;


-- =============================================================================
-- STEP 3: RLS Policies
-- =============================================================================

-- chat_credits: participants can view their chat's credits
CREATE POLICY "Participants can view chat credits"
    ON public.chat_credits FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.participants p
            WHERE p.chat_id = chat_credits.chat_id
              AND p.user_id = auth.uid()
              AND p.status = 'active'
        )
    );

-- chat_credit_transactions: host can view transaction history
CREATE POLICY "Host can view credit transactions"
    ON public.chat_credit_transactions FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.participants p
            WHERE p.chat_id = chat_credit_transactions.chat_id
              AND p.user_id = auth.uid()
              AND p.is_host = TRUE
              AND p.status = 'active'
        )
    );

-- round_funding: participants can view funding status
CREATE POLICY "Participants can view round funding"
    ON public.round_funding FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.participants p
            JOIN public.rounds r ON r.id = round_funding.round_id
            JOIN public.cycles c ON c.id = r.cycle_id
            WHERE p.chat_id = c.chat_id
              AND p.user_id = auth.uid()
              AND p.status = 'active'
        )
    );


-- =============================================================================
-- STEP 4: Add funding check to skip policies
-- =============================================================================

-- round_skips: unfunded participants cannot skip (they're spectating anyway)
DROP POLICY IF EXISTS "Users can skip in rounds they participate in" ON public.round_skips;

CREATE POLICY "Users can skip in rounds they participate in" ON public.round_skips
    FOR INSERT WITH CHECK (
        -- Verify participant belongs to current user
        participant_id IN (
            SELECT id FROM participants WHERE user_id = auth.uid()
        )
        -- Verify round is in proposing phase
        AND EXISTS (
            SELECT 1 FROM rounds WHERE id = round_id AND phase = 'proposing'
        )
        -- Verify user hasn't already submitted a proposition
        AND NOT EXISTS (
            SELECT 1 FROM propositions
            WHERE propositions.round_id = round_skips.round_id
              AND propositions.participant_id = round_skips.participant_id
              AND propositions.carried_from_id IS NULL
        )
        -- Verify skip quota not exceeded
        AND count_round_skips(round_id) < (
            SELECT COUNT(*)::INTEGER FROM participants p
            JOIN cycles c ON p.chat_id = c.chat_id
            JOIN rounds r ON r.cycle_id = c.id
            WHERE r.id = round_skips.round_id AND p.status = 'active'
        ) - COALESCE((
            SELECT ch.proposing_minimum FROM chats ch
            JOIN cycles c ON c.chat_id = ch.id
            JOIN rounds r ON r.cycle_id = c.id
            WHERE r.id = round_skips.round_id
        ), 1)
        -- Must be funded to skip (unfunded = spectator).
        -- Backward compat: if no funding records exist for this round, allow skip.
        AND (
            NOT EXISTS (
                SELECT 1 FROM round_funding rf2
                WHERE rf2.round_id = round_skips.round_id
            )
            OR EXISTS (
                SELECT 1 FROM round_funding rf
                WHERE rf.round_id = round_skips.round_id
                  AND rf.participant_id = round_skips.participant_id
            )
        )
    );


-- rating_skips: unfunded participants cannot skip
DROP POLICY IF EXISTS "Users can skip rating in rounds they participate in" ON public.rating_skips;

CREATE POLICY "Users can skip rating in rounds they participate in" ON public.rating_skips
    FOR INSERT WITH CHECK (
        -- Verify participant belongs to current user
        participant_id IN (
            SELECT id FROM participants WHERE user_id = auth.uid()
        )
        -- Verify round is in rating phase
        AND EXISTS (
            SELECT 1 FROM rounds WHERE id = round_id AND phase = 'rating'
        )
        -- Verify user hasn't already submitted any ratings for this round
        AND NOT EXISTS (
            SELECT 1 FROM grid_rankings gr
            JOIN propositions p ON p.id = gr.proposition_id
            WHERE p.round_id = rating_skips.round_id
              AND gr.participant_id = rating_skips.participant_id
        )
        -- Verify skip quota not exceeded
        AND count_rating_skips(round_id) < (
            SELECT COUNT(*)::INTEGER FROM participants p
            JOIN cycles c ON p.chat_id = c.chat_id
            JOIN rounds r ON r.cycle_id = c.id
            WHERE r.id = rating_skips.round_id AND p.status = 'active'
        ) - COALESCE((
            SELECT ch.rating_minimum FROM chats ch
            JOIN cycles c ON c.chat_id = ch.id
            JOIN rounds r ON r.cycle_id = c.id
            WHERE r.id = rating_skips.round_id
        ), 2)
        -- Must be funded to skip (unfunded = spectator).
        -- Backward compat: if no funding records exist for this round, allow skip.
        AND (
            NOT EXISTS (
                SELECT 1 FROM round_funding rf2
                WHERE rf2.round_id = rating_skips.round_id
            )
            OR EXISTS (
                SELECT 1 FROM round_funding rf
                WHERE rf.round_id = rating_skips.round_id
                  AND rf.participant_id = rating_skips.participant_id
            )
        )
    );


-- =============================================================================
-- STEP 5: Helper Functions
-- =============================================================================

-- Check if a chat has enough credits for all active participants
CREATE OR REPLACE FUNCTION public.can_round_start(p_chat_id BIGINT)
RETURNS BOOLEAN
LANGUAGE SQL
STABLE
SECURITY DEFINER
AS $$
    SELECT COALESCE(
        (SELECT cc.credit_balance >= (
            SELECT COUNT(*) FROM public.participants
            WHERE chat_id = p_chat_id AND status = 'active'
        )
        FROM public.chat_credits cc
        WHERE cc.chat_id = p_chat_id),
        FALSE  -- No chat_credits row = cannot start
    );
$$;

COMMENT ON FUNCTION public.can_round_start IS
'Returns true if the chat has enough credits to fund all active participants for a round.';


-- Count funded participants for a round
CREATE OR REPLACE FUNCTION public.get_funded_participant_count(p_round_id BIGINT)
RETURNS INTEGER
LANGUAGE SQL
STABLE
SECURITY DEFINER
AS $$
    SELECT COUNT(*)::INTEGER FROM public.round_funding WHERE round_id = p_round_id;
$$;

COMMENT ON FUNCTION public.get_funded_participant_count IS
'Returns the number of funded participants for a given round.';


-- Check if a specific participant is funded for a round
CREATE OR REPLACE FUNCTION public.is_participant_funded(
    p_round_id BIGINT,
    p_participant_id BIGINT
)
RETURNS BOOLEAN
LANGUAGE SQL
STABLE
SECURITY DEFINER
AS $$
    SELECT EXISTS (
        SELECT 1 FROM public.round_funding
        WHERE round_id = p_round_id AND participant_id = p_participant_id
    );
$$;

COMMENT ON FUNCTION public.is_participant_funded IS
'Returns true if the participant is funded for the given round.';


-- =============================================================================
-- STEP 6: Core Credit Operations
-- =============================================================================

-- Fund participants for a round start. Returns the number funded.
CREATE OR REPLACE FUNCTION public.fund_round_participants(
    p_round_id BIGINT,
    p_chat_id  BIGINT
)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_balance        INTEGER;
    v_active_count   INTEGER;
    v_funded_count   INTEGER;
    v_participant    RECORD;
BEGIN
    -- Lock credit row to prevent races
    SELECT credit_balance INTO v_balance
    FROM public.chat_credits
    WHERE chat_id = p_chat_id
    FOR UPDATE;

    IF v_balance IS NULL THEN
        RAISE EXCEPTION 'No chat_credits row for chat_id %', p_chat_id;
    END IF;

    -- Count active participants
    SELECT COUNT(*) INTO v_active_count
    FROM public.participants
    WHERE chat_id = p_chat_id AND status = 'active';

    -- Fund as many as we can afford, ordered by join time (host first)
    v_funded_count := LEAST(v_active_count, v_balance);

    IF v_funded_count <= 0 THEN
        RETURN 0;
    END IF;

    -- Insert funding records for the funded participants (idempotent)
    WITH inserted AS (
        INSERT INTO public.round_funding (round_id, participant_id)
        SELECT p_round_id, p.id
        FROM public.participants p
        WHERE p.chat_id = p_chat_id AND p.status = 'active'
        ORDER BY p.created_at ASC
        LIMIT v_funded_count
        ON CONFLICT (round_id, participant_id) DO NOTHING
        RETURNING id
    )
    SELECT COUNT(*) INTO v_funded_count FROM inserted;

    -- Nothing new to fund (already funded or 0 participants)
    IF v_funded_count <= 0 THEN
        RETURN 0;
    END IF;

    -- Deduct credits
    UPDATE public.chat_credits
    SET credit_balance = credit_balance - v_funded_count,
        updated_at = NOW()
    WHERE chat_id = p_chat_id;

    -- Record transaction
    INSERT INTO public.chat_credit_transactions
        (chat_id, transaction_type, amount, balance_after, round_id, participant_count)
    VALUES
        (p_chat_id, 'round_start', -v_funded_count, v_balance - v_funded_count,
         p_round_id, v_funded_count);

    RETURN v_funded_count;
END;
$$;

COMMENT ON FUNCTION public.fund_round_participants IS
'Funds active participants for a round, deducting from chat credits. Returns funded count.
Participants are funded in join-order (host first). Locks credit row to prevent races.';


-- Fund a mid-round joiner. Returns true if funded, false if insufficient credits.
CREATE OR REPLACE FUNCTION public.fund_mid_round_join(
    p_participant_id BIGINT,
    p_chat_id        BIGINT
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_round_id BIGINT;
    v_balance  INTEGER;
BEGIN
    -- Find current active round (proposing or rating, not completed)
    SELECT r.id INTO v_round_id
    FROM public.rounds r
    JOIN public.cycles c ON c.id = r.cycle_id
    WHERE c.chat_id = p_chat_id
      AND r.phase IN ('proposing', 'rating')
    ORDER BY r.id DESC
    LIMIT 1;

    -- No active round — nothing to fund
    IF v_round_id IS NULL THEN
        RETURN TRUE;  -- Not an error; no round in progress
    END IF;

    -- Already funded? Idempotent.
    IF EXISTS (
        SELECT 1 FROM public.round_funding
        WHERE round_id = v_round_id AND participant_id = p_participant_id
    ) THEN
        RETURN TRUE;
    END IF;

    -- Lock and check balance
    SELECT credit_balance INTO v_balance
    FROM public.chat_credits
    WHERE chat_id = p_chat_id
    FOR UPDATE;

    IF v_balance IS NULL OR v_balance < 1 THEN
        RETURN FALSE;  -- Insufficient credits — spectator
    END IF;

    -- Fund the participant
    INSERT INTO public.round_funding (round_id, participant_id)
    VALUES (v_round_id, p_participant_id);

    -- Deduct 1 credit
    UPDATE public.chat_credits
    SET credit_balance = credit_balance - 1,
        updated_at = NOW()
    WHERE chat_id = p_chat_id;

    -- Record transaction
    INSERT INTO public.chat_credit_transactions
        (chat_id, transaction_type, amount, balance_after, round_id, participant_count)
    VALUES
        (p_chat_id, 'mid_round_join', -1, v_balance - 1, v_round_id, 1);

    RETURN TRUE;
END;
$$;

COMMENT ON FUNCTION public.fund_mid_round_join IS
'Funds a mid-round joiner from chat credits. Returns false if no credits available (spectator mode).
Idempotent: returns true if already funded. Returns true if no active round.';


-- Add purchased credits to a chat (idempotent via Stripe session ID)
CREATE OR REPLACE FUNCTION public.add_chat_credits(
    p_chat_id            BIGINT,
    p_amount             INTEGER,
    p_stripe_session_id  TEXT
)
RETURNS public.chat_credits
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_result public.chat_credits;
    v_existing_txn BIGINT;
BEGIN
    IF p_amount <= 0 THEN
        RAISE EXCEPTION 'Credit amount must be positive';
    END IF;

    -- Idempotency check: if this Stripe session was already processed, return current balance
    IF p_stripe_session_id IS NOT NULL THEN
        SELECT id INTO v_existing_txn
        FROM public.chat_credit_transactions
        WHERE stripe_checkout_session_id = p_stripe_session_id;

        IF v_existing_txn IS NOT NULL THEN
            -- Already processed — return current balance without modifying
            SELECT * INTO v_result
            FROM public.chat_credits
            WHERE chat_id = p_chat_id;
            RETURN v_result;
        END IF;
    END IF;

    -- Add credits
    UPDATE public.chat_credits
    SET credit_balance = credit_balance + p_amount,
        updated_at = NOW()
    WHERE chat_id = p_chat_id
    RETURNING * INTO v_result;

    IF v_result IS NULL THEN
        RAISE EXCEPTION 'No chat_credits row for chat_id %', p_chat_id;
    END IF;

    -- Record transaction
    INSERT INTO public.chat_credit_transactions
        (chat_id, transaction_type, amount, balance_after, stripe_checkout_session_id)
    VALUES
        (p_chat_id, 'purchase', p_amount, v_result.credit_balance, p_stripe_session_id);

    -- Check if a credit-paused round can now resume
    PERFORM public.check_credit_resume(p_chat_id);

    RETURN v_result;
END;
$$;

COMMENT ON FUNCTION public.add_chat_credits IS
'Adds purchased credits to a chat. Idempotent via unique constraint on stripe_checkout_session_id.
Automatically checks if a credit-paused round can resume after adding credits.';


-- Resume a credit-paused round after credits are added
CREATE OR REPLACE FUNCTION public.check_credit_resume(p_chat_id BIGINT)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_round RECORD;
    v_chat  RECORD;
    v_participant_count INTEGER;
    v_phase_ends_at TIMESTAMPTZ;
BEGIN
    -- Find a waiting round with NO new propositions (credit-paused, not waiting-for-rating)
    SELECT r.id, r.cycle_id INTO v_round
    FROM public.rounds r
    JOIN public.cycles c ON c.id = r.cycle_id
    WHERE c.chat_id = p_chat_id
      AND r.phase = 'waiting'
      AND NOT EXISTS (
          SELECT 1 FROM public.propositions p
          WHERE p.round_id = r.id AND p.carried_from_id IS NULL
      )
    ORDER BY r.id DESC
    LIMIT 1;

    IF v_round IS NULL THEN
        RETURN;  -- No credit-paused round
    END IF;

    -- Get chat settings
    SELECT * INTO v_chat
    FROM public.chats
    WHERE id = p_chat_id;

    -- Only resume auto-mode chats
    IF v_chat.start_mode != 'auto' THEN
        RETURN;
    END IF;

    -- Check participant threshold
    SELECT COUNT(*) INTO v_participant_count
    FROM public.participants
    WHERE chat_id = p_chat_id AND status = 'active';

    IF v_participant_count < v_chat.auto_start_participant_count THEN
        RETURN;  -- Not enough participants yet
    END IF;

    -- Check credits
    IF NOT public.can_round_start(p_chat_id) THEN
        RETURN;  -- Still not enough credits
    END IF;

    -- Resume: advance to proposing phase
    v_phase_ends_at := calculate_round_minute_end(v_chat.proposing_duration_seconds);

    UPDATE public.rounds
    SET phase = 'proposing',
        phase_started_at = NOW(),
        phase_ends_at = v_phase_ends_at
    WHERE id = v_round.id;

    -- Fund participants
    PERFORM public.fund_round_participants(v_round.id, p_chat_id);
END;
$$;

COMMENT ON FUNCTION public.check_credit_resume IS
'Resumes a credit-paused waiting round after credits are added.
Only applies to auto-mode chats with sufficient participants and credits.';


-- =============================================================================
-- STEP 7: Auto-creation trigger — insert chat_credits on chat creation
-- =============================================================================

CREATE OR REPLACE FUNCTION public.on_chat_insert_create_credits()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    INSERT INTO public.chat_credits (chat_id, credit_balance)
    VALUES (NEW.id, 50);

    INSERT INTO public.chat_credit_transactions
        (chat_id, transaction_type, amount, balance_after)
    VALUES
        (NEW.id, 'initial', 50, 50);

    RETURN NEW;
END;
$$;

CREATE TRIGGER trg_chat_insert_create_credits
    AFTER INSERT ON public.chats
    FOR EACH ROW
    EXECUTE FUNCTION public.on_chat_insert_create_credits();

COMMENT ON FUNCTION public.on_chat_insert_create_credits IS
'Auto-creates a chat_credits row with 50 free credits when a new chat is created.';


-- =============================================================================
-- STEP 8: Modify create_round_for_cycle — credit-gate round creation
-- =============================================================================

CREATE OR REPLACE FUNCTION create_round_for_cycle(
    p_cycle_id BIGINT,
    p_chat_id BIGINT,
    p_custom_id INTEGER DEFAULT 1
) RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_chat RECORD;
    v_participant_count INTEGER;
    v_new_round_id BIGINT;
    v_phase_ends_at TIMESTAMPTZ;
    v_has_credits BOOLEAN;
    v_funded_count INTEGER;
BEGIN
    -- Get chat settings
    SELECT
        c.start_mode,
        c.auto_start_participant_count,
        c.proposing_duration_seconds
    INTO v_chat
    FROM chats c
    WHERE c.id = p_chat_id;

    -- Check if auto-start conditions are met
    IF v_chat.start_mode = 'auto' THEN
        -- Count active participants
        SELECT COUNT(*) INTO v_participant_count
        FROM participants
        WHERE chat_id = p_chat_id
        AND status = 'active';

        IF v_participant_count >= v_chat.auto_start_participant_count THEN
            -- Check if we have enough credits
            v_has_credits := public.can_round_start(p_chat_id);

            IF v_has_credits THEN
                -- Sufficient credits: create in proposing phase with timer
                v_phase_ends_at := calculate_round_minute_end(v_chat.proposing_duration_seconds);

                INSERT INTO rounds (cycle_id, custom_id, phase, phase_started_at, phase_ends_at)
                VALUES (p_cycle_id, p_custom_id, 'proposing', NOW(), v_phase_ends_at)
                RETURNING id INTO v_new_round_id;

                -- Fund participants for this round
                v_funded_count := public.fund_round_participants(v_new_round_id, p_chat_id);

                RAISE NOTICE '[CREATE ROUND] Created proposing round % with % funded participants',
                    v_new_round_id, v_funded_count;

                RETURN v_new_round_id;
            ELSE
                -- Insufficient credits: create in waiting (credit-paused)
                RAISE NOTICE '[CREATE ROUND] Insufficient credits for chat %, creating credit-paused round',
                    p_chat_id;
            END IF;
        END IF;
    END IF;

    -- Manual mode, conditions not met, or insufficient credits: create in waiting phase
    INSERT INTO rounds (cycle_id, custom_id, phase)
    VALUES (p_cycle_id, p_custom_id, 'waiting')
    RETURNING id INTO v_new_round_id;

    RETURN v_new_round_id;
END;
$$;

COMMENT ON FUNCTION create_round_for_cycle IS
'Creates a round for a cycle. For auto-mode chats with sufficient participants AND credits,
creates in proposing phase and funds participants. Otherwise creates in waiting phase.
Insufficient credits result in a credit-paused waiting round.';


-- =============================================================================
-- STEP 9: Modify check_auto_start_on_participant_join — fund mid-round joiners
-- =============================================================================

CREATE OR REPLACE FUNCTION check_auto_start_on_participant_join()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_chat RECORD;
    v_participant_count INTEGER;
    v_existing_cycle_id INTEGER;
    v_new_cycle_id BIGINT;
    v_new_round_id BIGINT;
    v_funded BOOLEAN;
BEGIN
    -- Only proceed for active participants (not pending approval)
    IF NEW.status != 'active' THEN
        RETURN NEW;
    END IF;

    -- Get chat settings
    SELECT
        c.id,
        c.start_mode,
        c.auto_start_participant_count
    INTO v_chat
    FROM chats c
    WHERE c.id = NEW.chat_id;

    -- Only proceed if chat is in auto mode
    IF v_chat.start_mode != 'auto' THEN
        RETURN NEW;
    END IF;

    -- Check if there's already an existing cycle (chat already started)
    SELECT id INTO v_existing_cycle_id
    FROM cycles
    WHERE chat_id = NEW.chat_id
    LIMIT 1;

    IF v_existing_cycle_id IS NOT NULL THEN
        -- Chat already started: fund this mid-round joiner if possible
        v_funded := public.fund_mid_round_join(NEW.id, NEW.chat_id);

        RAISE NOTICE '[AUTO-START] Mid-round join for participant %, funded: %',
            NEW.id, v_funded;

        RETURN NEW;
    END IF;

    -- Count active participants
    SELECT COUNT(*) INTO v_participant_count
    FROM participants
    WHERE chat_id = NEW.chat_id
    AND status = 'active';

    RAISE NOTICE '[AUTO-START] Chat % has % active participants, threshold is %',
        NEW.chat_id, v_participant_count, v_chat.auto_start_participant_count;

    -- Check if we've reached the threshold
    IF v_participant_count >= v_chat.auto_start_participant_count THEN
        RAISE NOTICE '[AUTO-START] Threshold reached! Creating cycle and round for chat %', NEW.chat_id;

        -- Create first cycle
        INSERT INTO cycles (chat_id)
        VALUES (NEW.chat_id)
        RETURNING id INTO v_new_cycle_id;

        -- Create first round using shared helper
        -- (will check credits and fund participants if sufficient)
        v_new_round_id := create_round_for_cycle(v_new_cycle_id, NEW.chat_id, 1);

        -- Update chat last_activity_at
        UPDATE chats
        SET last_activity_at = NOW()
        WHERE id = NEW.chat_id;

        RAISE NOTICE '[AUTO-START] Created cycle % and round % for chat %',
            v_new_cycle_id, v_new_round_id, NEW.chat_id;
    END IF;

    RETURN NEW;
END;
$$;

COMMENT ON FUNCTION check_auto_start_on_participant_join IS
'Auto-starts a chat when participant count reaches threshold. For already-started chats,
funds the new participant for the current round if credits are available.';


-- =============================================================================
-- STEP 10: Modify early-advance triggers to use funded participant count
-- =============================================================================

-- 10a. check_early_advance_on_proposition
CREATE OR REPLACE FUNCTION check_early_advance_on_proposition()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_round RECORD;
    v_chat RECORD;
    v_funded_count INTEGER;
    v_proposition_count INTEGER;
    v_skip_count INTEGER;
    v_unique_submitters INTEGER;
    v_participated_count INTEGER;
    v_max_possible INTEGER;
    v_percent_required INTEGER;
    v_effective_count_threshold INTEGER;
    v_percent_met BOOLEAN;
    v_count_met BOOLEAN;
    v_minimum_met BOOLEAN;
    v_now TIMESTAMPTZ;
    v_phase_ends_at TIMESTAMPTZ;
BEGIN
    -- Get round info
    SELECT * INTO v_round
    FROM public.rounds
    WHERE id = NEW.round_id;

    -- Only check during proposing phase
    IF v_round.phase != 'proposing' THEN
        RETURN NEW;
    END IF;

    -- Get chat settings
    SELECT * INTO v_chat
    FROM public.chats
    WHERE id = (SELECT chat_id FROM public.cycles WHERE id = v_round.cycle_id);

    -- Skip if no proposing threshold configured
    IF v_chat.proposing_threshold_count IS NULL AND v_chat.proposing_threshold_percent IS NULL THEN
        RETURN NEW;
    END IF;

    -- Use FUNDED participant count (unfunded spectators don't count toward thresholds)
    v_funded_count := public.get_funded_participant_count(NEW.round_id);

    -- Fallback: if no funding records yet, use active count (backward compat)
    IF v_funded_count = 0 THEN
        SELECT COUNT(*) INTO v_funded_count
        FROM public.participants
        WHERE chat_id = v_chat.id AND status = 'active';
    END IF;

    -- Count skips for this round
    SELECT COUNT(*) INTO v_skip_count
    FROM public.round_skips
    WHERE round_id = NEW.round_id;

    -- Count NEW HUMAN propositions only (exclude carried forward AND AI)
    SELECT COUNT(*) INTO v_proposition_count
    FROM public.propositions
    WHERE round_id = NEW.round_id
      AND carried_from_id IS NULL
      AND participant_id IS NOT NULL;

    -- Count unique human submitters
    SELECT COUNT(DISTINCT participant_id) INTO v_unique_submitters
    FROM public.propositions
    WHERE round_id = NEW.round_id
      AND carried_from_id IS NULL
      AND participant_id IS NOT NULL;

    -- Participated = unique submitters + skippers
    v_participated_count := v_unique_submitters + v_skip_count;

    -- Max possible submissions (can't have more submitters than non-skippers)
    v_max_possible := v_funded_count - v_skip_count;

    -- Calculate percent-based requirement (rounded up)
    IF v_chat.proposing_threshold_percent IS NOT NULL THEN
        v_percent_required := CEIL(v_funded_count * v_chat.proposing_threshold_percent / 100.0);
    ELSE
        v_percent_required := 0;
    END IF;

    -- Count-based requirement with dynamic adjustment for skips
    IF v_chat.proposing_threshold_count IS NOT NULL THEN
        v_effective_count_threshold := LEAST(v_chat.proposing_threshold_count, v_max_possible);
    ELSE
        v_effective_count_threshold := 0;
    END IF;

    -- Check BOTH thresholds independently (AND, not LEAST/GREATEST)
    v_percent_met := v_participated_count >= v_percent_required;
    v_count_met := v_unique_submitters >= v_effective_count_threshold;
    v_minimum_met := v_proposition_count >= LEAST(v_chat.proposing_minimum, v_max_possible);

    RAISE NOTICE '[EARLY ADVANCE] Round %: % submitters + % skips = % participated (need %). Count: % (need %). Min: % (need %). Funded: %.',
        NEW.round_id, v_unique_submitters, v_skip_count, v_participated_count, v_percent_required,
        v_unique_submitters, v_effective_count_threshold,
        v_proposition_count, LEAST(v_chat.proposing_minimum, v_max_possible),
        v_funded_count;

    -- ALL three checks must pass
    IF v_percent_met AND v_count_met AND v_minimum_met THEN
        IF v_chat.rating_start_mode = 'auto' THEN
            -- Auto-advance to rating phase
            v_now := NOW();
            v_phase_ends_at := date_trunc('minute', v_now) +
                               INTERVAL '1 minute' * CEIL(v_chat.rating_duration_seconds / 60.0);

            RAISE NOTICE '[EARLY ADVANCE] Advancing round % to rating. % human props, % funded participants.',
                NEW.round_id, v_proposition_count, v_funded_count;

            UPDATE public.rounds
            SET phase = 'rating',
                phase_started_at = v_now,
                phase_ends_at = v_phase_ends_at
            WHERE id = NEW.round_id;
        ELSE
            -- Manual rating start mode: go to waiting phase
            RAISE NOTICE '[EARLY ADVANCE] Round % waiting for manual rating start.',
                NEW.round_id;

            UPDATE public.rounds
            SET phase = 'waiting',
                phase_started_at = NULL,
                phase_ends_at = NULL
            WHERE id = NEW.round_id;
        END IF;
    END IF;

    RETURN NEW;
END;
$$;


-- 10b. check_early_advance_on_skip
CREATE OR REPLACE FUNCTION check_early_advance_on_skip()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_round RECORD;
    v_chat RECORD;
    v_funded_count INTEGER;
    v_proposition_count INTEGER;
    v_skip_count INTEGER;
    v_unique_submitters INTEGER;
    v_participated_count INTEGER;
    v_max_possible INTEGER;
    v_percent_required INTEGER;
    v_effective_count_threshold INTEGER;
    v_percent_met BOOLEAN;
    v_count_met BOOLEAN;
    v_minimum_met BOOLEAN;
    v_now TIMESTAMPTZ;
    v_phase_ends_at TIMESTAMPTZ;
BEGIN
    -- Get round info
    SELECT * INTO v_round
    FROM public.rounds
    WHERE id = NEW.round_id;

    -- Only check during proposing phase
    IF v_round.phase != 'proposing' THEN
        RETURN NEW;
    END IF;

    -- Get chat settings
    SELECT * INTO v_chat
    FROM public.chats
    WHERE id = (SELECT chat_id FROM public.cycles WHERE id = v_round.cycle_id);

    -- Skip if no proposing threshold configured
    IF v_chat.proposing_threshold_count IS NULL AND v_chat.proposing_threshold_percent IS NULL THEN
        RETURN NEW;
    END IF;

    -- Use FUNDED participant count
    v_funded_count := public.get_funded_participant_count(NEW.round_id);

    IF v_funded_count = 0 THEN
        SELECT COUNT(*) INTO v_funded_count
        FROM public.participants
        WHERE chat_id = v_chat.id AND status = 'active';
    END IF;

    -- Count skips for this round (including the one just inserted)
    SELECT COUNT(*) INTO v_skip_count
    FROM public.round_skips
    WHERE round_id = NEW.round_id;

    -- Count NEW HUMAN propositions only
    SELECT COUNT(*) INTO v_proposition_count
    FROM public.propositions
    WHERE round_id = NEW.round_id
      AND carried_from_id IS NULL
      AND participant_id IS NOT NULL;

    -- Count unique human submitters
    SELECT COUNT(DISTINCT participant_id) INTO v_unique_submitters
    FROM public.propositions
    WHERE round_id = NEW.round_id
      AND carried_from_id IS NULL
      AND participant_id IS NOT NULL;

    v_participated_count := v_unique_submitters + v_skip_count;
    v_max_possible := v_funded_count - v_skip_count;

    IF v_chat.proposing_threshold_percent IS NOT NULL THEN
        v_percent_required := CEIL(v_funded_count * v_chat.proposing_threshold_percent / 100.0);
    ELSE
        v_percent_required := 0;
    END IF;

    IF v_chat.proposing_threshold_count IS NOT NULL THEN
        v_effective_count_threshold := LEAST(v_chat.proposing_threshold_count, v_max_possible);
    ELSE
        v_effective_count_threshold := 0;
    END IF;

    v_percent_met := v_participated_count >= v_percent_required;
    v_count_met := v_unique_submitters >= v_effective_count_threshold;
    v_minimum_met := v_proposition_count >= LEAST(v_chat.proposing_minimum, v_max_possible);

    RAISE NOTICE '[EARLY ADVANCE ON SKIP] Round %: % submitters + % skips = % participated (need %). Count: % (need %). Min: % (need %). Funded: %.',
        NEW.round_id, v_unique_submitters, v_skip_count, v_participated_count, v_percent_required,
        v_unique_submitters, v_effective_count_threshold,
        v_proposition_count, LEAST(v_chat.proposing_minimum, v_max_possible),
        v_funded_count;

    IF v_percent_met AND v_count_met AND v_minimum_met THEN
        IF v_chat.rating_start_mode = 'auto' THEN
            v_now := NOW();
            v_phase_ends_at := date_trunc('minute', v_now) +
                               INTERVAL '1 minute' * CEIL(v_chat.rating_duration_seconds / 60.0);

            UPDATE public.rounds
            SET phase = 'rating',
                phase_started_at = v_now,
                phase_ends_at = v_phase_ends_at
            WHERE id = NEW.round_id;
        ELSE
            UPDATE public.rounds
            SET phase = 'waiting',
                phase_started_at = NULL,
                phase_ends_at = NULL
            WHERE id = NEW.round_id;
        END IF;
    END IF;

    RETURN NEW;
END;
$$;


-- 10c. check_early_advance_on_rating
CREATE OR REPLACE FUNCTION check_early_advance_on_rating()
RETURNS TRIGGER AS $$
DECLARE
    v_proposition RECORD;
    v_round RECORD;
    v_chat RECORD;
    v_total_participants INTEGER;
    v_done_count INTEGER;
    v_required INTEGER;
    v_has_funding BOOLEAN;
BEGIN
    -- Get proposition and round info
    SELECT p.*, r.id as round_id, r.phase, r.cycle_id, c.chat_id
    INTO v_proposition
    FROM propositions p
    JOIN rounds r ON r.id = p.round_id
    JOIN cycles c ON c.id = r.cycle_id
    WHERE p.id = NEW.proposition_id;

    -- Only check during rating phase
    IF v_proposition.phase != 'rating' THEN
        RETURN NEW;
    END IF;

    -- Get chat settings
    SELECT * INTO v_chat
    FROM chats
    WHERE id = v_proposition.chat_id;

    -- Skip if no thresholds configured
    IF v_chat.rating_threshold_percent IS NULL AND v_chat.rating_threshold_count IS NULL THEN
        RETURN NEW;
    END IF;

    -- Skip manual mode
    IF v_chat.start_mode = 'manual' THEN
        RETURN NEW;
    END IF;

    -- Use FUNDED participant count (unfunded spectators don't count)
    v_total_participants := public.get_funded_participant_count(v_proposition.round_id);
    v_has_funding := v_total_participants > 0;

    -- Fallback: if no funding records, use active count (backward compat for pre-credit rounds)
    IF NOT v_has_funding THEN
        SELECT COUNT(*) INTO v_total_participants
        FROM participants
        WHERE chat_id = v_proposition.chat_id AND status = 'active';
    END IF;

    IF v_total_participants = 0 THEN
        RETURN NEW;
    END IF;

    -- Count participants who are "done":
    -- either skipped rating OR rated all propositions except their own
    -- When funding records exist, only count funded participants.
    -- When no funding records (pre-credit rounds), count all active participants.
    SELECT COUNT(*) INTO v_done_count
    FROM participants p
    WHERE p.chat_id = v_proposition.chat_id AND p.status = 'active'
    -- Only filter by funding when funding records exist
    AND (
        NOT v_has_funding
        OR EXISTS (
            SELECT 1 FROM round_funding rf
            WHERE rf.round_id = v_proposition.round_id AND rf.participant_id = p.id
        )
    )
    AND (
        -- Skipped rating
        EXISTS (
            SELECT 1 FROM rating_skips rs
            WHERE rs.round_id = v_proposition.round_id AND rs.participant_id = p.id
        )
        OR
        -- Rated all propositions except their own
        (
            SELECT COUNT(*) FROM grid_rankings gr
            WHERE gr.participant_id = p.id
            AND gr.proposition_id IN (
                SELECT id FROM propositions WHERE round_id = v_proposition.round_id
            )
        ) >= (
            SELECT COUNT(*) FROM propositions
            WHERE round_id = v_proposition.round_id
            AND (participant_id IS NULL OR participant_id != p.id)
        )
    );

    -- Calculate required threshold
    v_required := calculate_early_advance_required(
        v_chat.rating_threshold_percent,
        v_chat.rating_threshold_count,
        v_total_participants
    );

    -- Cap at total participants
    IF v_required IS NOT NULL AND v_required > v_total_participants THEN
        v_required := v_total_participants;
    END IF;

    IF v_required IS NOT NULL AND v_required < 1 THEN
        v_required := 1;
    END IF;

    -- Check if enough participants are done
    IF v_required IS NOT NULL AND v_done_count >= v_required THEN
        RAISE NOTICE '[EARLY ADVANCE] Rating threshold met (% done / % required, % funded). Completing round %.',
            v_done_count, v_required, v_total_participants, v_proposition.round_id;

        PERFORM complete_round_with_winner(v_proposition.round_id);
        PERFORM apply_adaptive_duration(v_proposition.round_id);
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- 10d. check_early_advance_on_rating_skip
CREATE OR REPLACE FUNCTION check_early_advance_on_rating_skip()
RETURNS TRIGGER AS $$
DECLARE
    v_round RECORD;
    v_chat RECORD;
    v_total_participants INTEGER;
    v_done_count INTEGER;
    v_required INTEGER;
    v_has_funding BOOLEAN;
BEGIN
    -- Get round info
    SELECT r.*, c.chat_id
    INTO v_round
    FROM rounds r
    JOIN cycles c ON c.id = r.cycle_id
    WHERE r.id = NEW.round_id;

    -- Only check during rating phase
    IF v_round.phase != 'rating' THEN
        RETURN NEW;
    END IF;

    -- Get chat settings
    SELECT * INTO v_chat
    FROM chats
    WHERE id = v_round.chat_id;

    -- Skip if no thresholds configured
    IF v_chat.rating_threshold_percent IS NULL AND v_chat.rating_threshold_count IS NULL THEN
        RETURN NEW;
    END IF;

    -- Skip manual mode
    IF v_chat.start_mode = 'manual' THEN
        RETURN NEW;
    END IF;

    -- Use FUNDED participant count
    v_total_participants := public.get_funded_participant_count(NEW.round_id);
    v_has_funding := v_total_participants > 0;

    IF NOT v_has_funding THEN
        SELECT COUNT(*) INTO v_total_participants
        FROM participants
        WHERE chat_id = v_round.chat_id AND status = 'active';
    END IF;

    IF v_total_participants = 0 THEN
        RETURN NEW;
    END IF;

    -- Count participants who are "done"
    -- When funding records exist, only count funded participants.
    -- When no funding records (pre-credit rounds), count all active participants.
    SELECT COUNT(*) INTO v_done_count
    FROM participants p
    WHERE p.chat_id = v_round.chat_id AND p.status = 'active'
    AND (
        NOT v_has_funding
        OR EXISTS (
            SELECT 1 FROM round_funding rf
            WHERE rf.round_id = NEW.round_id AND rf.participant_id = p.id
        )
    )
    AND (
        EXISTS (
            SELECT 1 FROM rating_skips rs
            WHERE rs.round_id = NEW.round_id AND rs.participant_id = p.id
        )
        OR
        (
            SELECT COUNT(*) FROM grid_rankings gr
            WHERE gr.participant_id = p.id
            AND gr.proposition_id IN (
                SELECT id FROM propositions WHERE round_id = NEW.round_id
            )
        ) >= (
            SELECT COUNT(*) FROM propositions
            WHERE round_id = NEW.round_id
            AND (participant_id IS NULL OR participant_id != p.id)
        )
    );

    -- Calculate required threshold
    v_required := calculate_early_advance_required(
        v_chat.rating_threshold_percent,
        v_chat.rating_threshold_count,
        v_total_participants
    );

    IF v_required IS NOT NULL AND v_required > v_total_participants THEN
        v_required := v_total_participants;
    END IF;

    IF v_required IS NOT NULL AND v_required < 1 THEN
        v_required := 1;
    END IF;

    IF v_required IS NOT NULL AND v_done_count >= v_required THEN
        RAISE NOTICE '[EARLY ADVANCE] Rating skip triggered advance (% done / % required, % funded). Completing round %.',
            v_done_count, v_required, v_total_participants, NEW.round_id;

        PERFORM complete_round_with_winner(NEW.round_id);
        PERFORM apply_adaptive_duration(NEW.round_id);
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- =============================================================================
-- STEP 11: Drop old per-user billing trigger
-- =============================================================================

DROP TRIGGER IF EXISTS trg_round_winner_track_usage ON public.rounds;

COMMENT ON FUNCTION public.on_round_winner_track_usage IS
'DEPRECATED: Old per-user billing trigger. Replaced by chat-based credits system.
Trigger has been dropped but function retained for rollback safety.';


-- =============================================================================
-- STEP 12: Backfill chat_credits for existing chats
-- =============================================================================

INSERT INTO public.chat_credits (chat_id, credit_balance)
SELECT id, 50
FROM public.chats
WHERE NOT EXISTS (
    SELECT 1 FROM public.chat_credits cc WHERE cc.chat_id = chats.id
);

INSERT INTO public.chat_credit_transactions (chat_id, transaction_type, amount, balance_after)
SELECT id, 'initial', 50, 50
FROM public.chats
WHERE NOT EXISTS (
    SELECT 1 FROM public.chat_credit_transactions cct
    WHERE cct.chat_id = chats.id AND cct.transaction_type = 'initial'
);


-- =============================================================================
-- MIGRATION COMPLETE
-- =============================================================================
